INCLUDE = [
  "multisense_05.cfg"
];

coordinate_frames {
  root_frame = "local";

  # the origin of the world is on the ground, directly underneath
  # the forward base edge of the mounted robot. Thus, this point
  # itself is z+ from the origin
  robot_table {
    relative_to = "local";
    history = 2000;
    max_frequency = 1000;
    update_channel = "ROBOT_TABLE";
    initial_transform{
      translation = [ 0, 0, .911 ]; #  35 7/8 " = .911 meters    (.921)
      rpy = [0, 0, 0];
    }
  }

  # robot urdf base relative to table edge
  robot_base {
    relative_to = "robot_table";
    history = 2000;
    max_frequency = 1000;
    update_channel = "ROBOT_BASE_TO_TABLE";
    initial_transform{
      translation = [ -0.17, 0, 0 ]; # -.17 , 0, 0  ## total: [ -1.69828967e-01,  -7.77272077e-02,   9.21085944e-01]
      rpy = [0, 0, 0];
    }
  }

  # yplus-apriltag position relative to table edge
  robot_yplus_tag {
    relative_to = "robot_table";
    history = 2000;
    max_frequency = 1000;
    update_channel = "ROBOT_BASE_TO_YPLUS_TAG";
    initial_transform{
      translation = [ -0.01, 0.35, -0.2 ];
      rpy = [-90, 0, 90];
    }
  }

  # this is the pelvis link, its a legacy that its referred to as body
  body {
    relative_to = "local";
    history = 2000;
    max_frequency = 1000;
    pose_update_channel = "POSE_BODY";
    #update_channel = "HEAD_TO_BODY";  
    initial_transform{
      translation = [ 0, 0, 0 ];
      rpy = [0, 0, 0];
    }
  }

  utorso {
    relative_to = "body";
    history = 2000;
    max_frequency = 10;
    update_channel = "BODY_TO_UTORSO";  
    initial_transform{
      translation = [ 0, 0, 0 ];
      quat = [ 1, 0, 0, 0 ];
    }
  }

  # ABB Kinect position, previously hard coded in kinectlcm.py
  # now, we set this to identity, as the apriltag system will be used to
  # infer camera position
  KINECT_RGB {
    relative_to = "body";
    history = 2000;
    max_frequency = 100;
    update_channel = "WORLD_TO_KINECT_RGB";  
    initial_transform{
      #Original Numbers
      #translation=[-0.17790587, -1.24393384, 0.22335996];
      #quat = [0.71466764, -0.64979598,  0.17682733, -0.18906994];
  
      # Version from lcmlog 2015-03-07.01
      #translation = [-0.14422686, -1.24711244,  0.19138616];
      #quat = [ 0.78701596, -0.56319487,  0.14177015, -0.20813131];

      # Version: no transform
      translation = [0,0,0];
      rpy = [0,0,0];
    }
  }

  KINECT_TO_APRILTAG {
    relative_to = "KINECT_RGB";
    history = 0;
    update_channel = "APRIL_TAG_TO_CAMERA_LEFT";
    initial_transform {
      translation = [0.0, 0.0, 0.0];
      rpy = [0.0, -90.0, 0.0];
    }
  }  

}


cameras {
  # fx fy skew cx cy 
  KINECT_RGB {
    lcm_channel = "KINECT_RGB";
    coord_frame = "KINECT_RGB";
    intrinsic_cal{
      width = 640;
      height= 480;
      distortion_model = "plumb-bob";
      distortion_k = [0,0,0];
      distortion_p = [0,0];
      pinhole = [ 528.01442863461716, 528.01442863461716, 0, 321.06398107, 242.97676897 ];
    }
  }
}
